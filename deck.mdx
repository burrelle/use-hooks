export { default as theme } from './theme';
import { Appear } from 'mdx-deck';
import { Split } from 'mdx-deck/layouts';
import { CodeBlock } from './src/components/CodeBlock';
import { Container } from './src/components/Styles';
import { StateCounterSource } from './source/StateCounterSource';
import { ES6CounterSource } from './source/ES6CounterSource';
import { ClassSource } from './source/ClassSource';
import { StatelessFunctionalSource } from './source/StatelessFunctionalSource';
import { ArrayDestructuring } from './source/ArrayDestructuring';
import Search from './src/components/Search';
import * as Fetch from './source/FetchData';
import * as Steps from './source/HooksCounterSteps';
import './script.js';

## The one with the hooks ğŸ£

Using state and other React features without classes

---

# It's a counter!

import StateCounter from './src/components/StateCounter';

## <StateCounter />

---

<CodeBlock>{StateCounterSource}</CodeBlock>

---

# ğŸ¤·ğŸ»â€â™‚

<CodeBlock>{`
this.increment = this.increment.bind(this);
this.decrement = this.decrement.bind(this);
`}</CodeBlock>

---

## Enter ES6

<CodeBlock>{ES6CounterSource}</CodeBlock>

---

### Different ways of writing React Components?

---

export default Split;

<Container>
  Classes
  <hr />
  <CodeBlock>{ClassSource}</CodeBlock>
</Container>

<Container>
<i>Stateless</i> Functional Components
<hr />
<CodeBlock>{StatelessFunctionalSource}</CodeBlock>
</Container>
---

Can we write more functions?

ğŸ¤”

---

Let's make a function for holding some state

â–¶ï¸

---

<CodeBlock style={{ fontSize: 32 }}>{`function useState()`}</CodeBlock>

---

<CodeBlock
  style={{ fontSize: 32 }}
>{`function useState(initialState)`}</CodeBlock>

---

<CodeBlock
  style={{ fontSize: 32 }}
>{`const [state, setState] = function useState(initialState)`}</CodeBlock>

---

â¸ï¸ï¸

<CodeBlock style={{ fontSize: 32 }}>{`const [state, setState]`}</CodeBlock>

---

Array Destructuring

<CodeBlock style={{ fontSize: 24 }}>{ArrayDestructuring}</CodeBlock>

---

ğŸ“ Rewrite our counter

---

export default Split;

<Container>
  <CodeBlock>{ES6CounterSource}</CodeBlock>
</Container>

<Container>
  ğŸ„ğŸ»â€â™‚ï¸
  <CodeBlock>{Steps.One}</CodeBlock>
</Container>

---

export default Split;

<Container>
  <CodeBlock>{ES6CounterSource}</CodeBlock>
</Container>

<Container>
  <CodeBlock>{Steps.Two}</CodeBlock>
</Container>

---

useState() Hook ğŸ£

---

export default Split;

<Container>
  <CodeBlock>{ES6CounterSource}</CodeBlock>
</Container>

<Container>
  <p>Value is just a variable</p>
  <CodeBlock>{Steps.Three}</CodeBlock>
</Container>

---

export default Split;

<Container>
  <CodeBlock>{ES6CounterSource}</CodeBlock>
</Container>

<Container>
  <CodeBlock>{Steps.Four}</CodeBlock>
</Container>

---

export default Split;

<Container>
  <CodeBlock>{ES6CounterSource}</CodeBlock>
</Container>

<Container>
  <p>
    No <i>this</i> required
  </p>
  <CodeBlock>{Steps.Four}</CodeBlock>
</Container>

---

import Counter from './src/components/Counter';

## <Counter />

---

Enough with the counting.

---

_Let's get some_ ğŸº

---

React Lifecycle Methods

<Container>
<Appear>
<p>componentWillMount</p>
<p>componentDidMount</p>
<p>componentWillUpdate</p>
<p>componentDidUpdate</p>
<p>componentWillUnmount</p>
ğŸ‘‹ğŸ»
</Appear>
</Container>
---

Let's fetch some data...

<Appear>
  <h2>ğŸº</h2>
</Appear>

---

<div style={{ textAlign: 'left' }}>
  You canâ€™t guarantee the AJAX request wonâ€™t resolve before the component
  mounts. If it did, that would mean that youâ€™d be trying to setState on an
  unmounted component, which not only wonâ€™t work, but React will yell at you
  for. Doing AJAX in componentDidMount will guarantee that thereâ€™s a component
  to update.
  <p style={{ textAlign: 'right' }}>- Tyler McGinnis</p>
</div>

---

export default Split;

<Container>
  Synchronously ğŸ‘´ğŸ»
  <CodeBlock>{Fetch.Sync}</CodeBlock>
</Container>

<Container>
  Asynchronously ğŸ˜
  <CodeBlock>{Fetch.Async}</CodeBlock>
</Container>

---

Brew Dog Search

<Search />
